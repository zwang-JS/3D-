<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D äº¤äº’å¼æµªæ¼«ç²’å­ç³»ç»Ÿ - æ¨¡å‹ä¿®å¤ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Montserrat', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        .interactive-element { pointer-events: auto; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.2rem; text-align: center;
            z-index: 20; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            pointer-events: none; transition: opacity 0.5s;
        }

        #toast {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(50, 200, 100, 0.9); color: white; padding: 10px 25px;
            border-radius: 25px; font-size: 0.95rem; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; z-index: 30; box-shadow: 0 4px 15px rgba(0,0,0,0.4); font-weight: 500;
        }

        .glass-panel {
            background: rgba(30, 30, 30, 0.4); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 16px;
            padding: 16px; color: white; transition: transform 0.2s;
            max-height: 80vh; display: flex; flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .scroll-area { overflow-y: auto; padding-right: 5px; margin-top: 10px; }
        #input_video { display: none; }
        button { transition: all 0.2s ease; }
        button:active { transform: scale(0.96); }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    </style>
</head>
<body>

    <div id="loader"><div>æ­£åœ¨æ„å»ºé«˜ç²¾æ¨¡å‹...</div></div>
    <div id="toast"></div>
    <video id="input_video"></video>

    <div id="ui-layer">
        <!-- é¡¶éƒ¨æ§åˆ¶æ  -->
        <div class="flex justify-between items-start h-full">
            <div class="glass-panel interactive-element w-72">
                <div class="flex-shrink-0">
                    <h1 class="text-2xl font-bold mb-1 bg-clip-text text-transparent bg-gradient-to-r from-pink-400 to-purple-400">ç²’å­å¹»å¢ƒ</h1>
                    <p class="text-xs text-gray-300 mb-4">20ç§é«˜ç²¾å½¢æ€ | æè‡´ç¨³å®šç”»é¢</p>
                    
                    <div class="flex items-center gap-3 mb-3 bg-white/5 p-2.5 rounded-lg border border-white/5">
                        <span class="text-xs font-medium text-gray-300">æ°›å›´æ»¤é•œ:</span>
                        <input type="color" id="colorPicker" value="#ffffff" class="w-6 h-6 rounded-full cursor-pointer border-none bg-transparent hover:scale-110 transition-transform">
                        <span class="text-[10px] text-gray-500 ml-auto">ç™½è‰²æ˜¾ç¤ºåŸå›¾</span>
                    </div>

                    <div class="flex gap-2 mb-3">
                        <button id="audioBtn" onclick="toggleAudio()" class="flex-1 bg-emerald-600/30 hover:bg-emerald-600/80 border border-emerald-500/30 py-2 rounded-lg text-xs font-medium transition-colors">ğŸµ å¾‹åŠ¨æ¨¡å¼</button>
                        <button onclick="takeSnapshot()" class="flex-1 bg-amber-600/30 hover:bg-amber-600/80 border border-amber-500/30 py-2 rounded-lg text-xs font-medium transition-colors">ğŸ“¸ ä¿å­˜ç”»é¢</button>
                    </div>
                    
                    <div class="text-xs text-gray-400 font-bold mt-2 pb-1 border-b border-white/10">é€‰æ‹©ç²¾ç»†æ¨¡å‹ (20ç§):</div>
                </div>

                <div class="scroll-area flex-grow grid grid-cols-2 gap-2" id="shape-list"></div>
            </div>

            <div class="interactive-element flex gap-2">
                <button onclick="toggleFullScreen()" class="glass-panel p-2 hover:bg-white/20 h-10 w-10 flex items-center justify-center rounded-full" title="å…¨å±">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" /></svg>
                </button>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶æ  -->
        <div class="flex justify-between items-end pb-4">
            <div class="glass-panel interactive-element w-72">
                <label class="flex items-center gap-2 text-xs font-bold mb-2 text-blue-300">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    ä¸Šä¼ ç…§ç‰‡ (æ”¯æŒå¤šé€‰)
                </label>
                <div class="text-[10px] text-gray-400 mb-3 leading-relaxed">
                    æŒ‰ä½ Ctrl/Shift å¯å¤šé€‰ã€‚<br>ç…§ç‰‡å°†éšæœºåˆ†é…ç»™ç²’å­ã€‚
                </div>
                <input type="file" id="imageUpload" multiple accept="image/*" class="text-xs w-full text-gray-300 file:mr-2 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 cursor-pointer"/>
            </div>

            <div class="glass-panel">
                <div class="flex items-center gap-3">
                    <div id="hand-indicator" class="w-3 h-3 rounded-full bg-red-500 shadow-inner"></div>
                    <div class="flex flex-col">
                        <span id="hand-status" class="text-xs font-bold">ç­‰å¾…æ‰‹åŠ¿...</span>
                        <span class="text-[10px] text-gray-400">å¯¹ç€æ‘„åƒå¤´å¼ åˆåŒæ‰‹</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. é…ç½® ---
        const CONFIG = {
            particleCount: 12000, 
            particleSize: 9.0,   
            defaultColor: new THREE.Color('#ffffff'),
            handSensitivity: 1.0, 
            atlasGrid: 4          
        };

        const SHAPES = [
            { id: 'heart', name: 'â¤ï¸ çˆ±å¿ƒ', color: '#ffaaaa' },
            { id: 'rose', name: 'ğŸŒ¹ ç«ç‘°', color: '#ff5555' },
            { id: 'tree', name: 'ğŸ„ æ¾æ ‘', color: '#88ff88' },
            { id: 'ring', name: 'ğŸ’ é’»æˆ’', color: '#aaffff' },
            { id: 'galaxy', name: 'ğŸŒŒ æ˜Ÿæ²³', color: '#ccaaff' },
            { id: 'butterfly', name: 'ğŸ¦‹ è´è¶', color: '#88ccff' },
            { id: 'star', name: 'â­ æ˜æ˜Ÿ', color: '#ffffaa' },
            { id: 'moon', name: 'ğŸŒ™ å¼¯æœˆ', color: '#ffcc88' },
            { id: 'infinity', name: 'â™¾ï¸ æ— é™', color: '#ffaaaa' },
            { id: 'snowflake', name: 'â„ï¸ é›ªèŠ±', color: '#ffffff' },
            { id: 'dna', name: 'ğŸ§¬ ç¾ç»Š', color: '#88aaff' },
            { id: 'diamond', name: 'ğŸ’ é’»çŸ³', color: '#ffffff' },
            { id: 'crown', name: 'ğŸ‘‘ çš‡å† ', color: '#ffcc55' },
            { id: 'balloon', name: 'ğŸˆ æ°”çƒ', color: '#ff8888' },
            { id: 'music', name: 'ğŸµ éŸ³ç¬¦', color: '#cc88ff' },
            { id: 'gift', name: 'ğŸ ç¤¼ç‰©', color: '#ffaa55' },
            { id: 'lips', name: 'ğŸ’‹ çº¢å”‡', color: '#ff5555' },
            { id: 'angel', name: 'ğŸ‘¼ ç¿…è†€', color: '#ffffff' },
            { id: 'sphere', name: 'ğŸ”® æ°´æ™¶çƒ', color: '#aaffcc' },
            { id: 'fireworks', name: 'ğŸ† çƒŸèŠ±', color: '#ffccff' }
        ];

        let scene, camera, renderer, particles, material, geometry, controls; 
        let clock = new THREE.Clock();
        let mouse = new THREE.Vector2();
        
        let currentShape = 'heart';
        let targetPositions = []; 
        let handExpansion = 0; 
        let targetHandExpansion = 0;
        let audioContext, analyser, dataArray;
        let isAudioActive = false;
        
        let textureAtlasCanvas, textureAtlasTexture;

        // --- 2. åˆå§‹åŒ–UI ---
        function initUI() {
            const list = document.getElementById('shape-list');
            SHAPES.forEach(shape => {
                const btn = document.createElement('button');
                btn.className = 'bg-white/5 hover:bg-white/10 border border-white/5 p-2 rounded text-xs text-left transition-all hover:pl-3 truncate text-gray-200';
                btn.innerText = shape.name;
                btn.onclick = () => {
                    setShape(shape.id);
                };
                list.appendChild(btn);
            });
        }

        // --- 3. çº¹ç†å›¾é›†ç”Ÿæˆ ---
        function initTextureAtlas() {
            textureAtlasCanvas = document.createElement('canvas');
            textureAtlasCanvas.width = 1024;
            textureAtlasCanvas.height = 1024;
            generateDefaultAtlas();
            textureAtlasTexture = new THREE.CanvasTexture(textureAtlasCanvas);
            textureAtlasTexture.minFilter = THREE.LinearMipmapLinearFilter;
            textureAtlasTexture.magFilter = THREE.LinearFilter;
        }

        function generateDefaultAtlas() {
            const ctx = textureAtlasCanvas.getContext('2d');
            ctx.clearRect(0, 0, 1024, 1024);
            const size = 1024 / CONFIG.atlasGrid;
            const symbols = ["â¤ï¸", "ğŸŒ¸", "âœ¨", "ğŸ’", "ğŸ¦‹", "â­", "ğŸµ", "ğŸ’‹", "ğŸ", "â„ï¸", "ğŸ‘‘", "ğŸ’", "ğŸŒ™", "ğŸŒ¹", "â˜€ï¸", "ğŸ€"];
            
            ctx.font = `${size * 0.6}px serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            for(let i=0; i<CONFIG.atlasGrid * CONFIG.atlasGrid; i++) {
                const col = i % CONFIG.atlasGrid;
                const row = Math.floor(i / CONFIG.atlasGrid);
                const x = col * size;
                const y = row * size;
                
                ctx.fillStyle = `rgba(255,255,255,${0.1 + Math.random()*0.1})`;
                ctx.beginPath();
                ctx.arc(x+size/2, y+size/2, size/2-10, 0, Math.PI*2);
                ctx.fill();

                ctx.fillStyle = "white";
                if (i < symbols.length) ctx.fillText(symbols[i], x + size/2, y + size/2 + size*0.05);
            }
            if (textureAtlasTexture) textureAtlasTexture.needsUpdate = true;
        }

        function updateAtlasWithImages(images) {
            const ctx = textureAtlasCanvas.getContext('2d');
            ctx.clearRect(0, 0, 1024, 1024);
            const size = 1024 / CONFIG.atlasGrid;
            const totalSlots = CONFIG.atlasGrid * CONFIG.atlasGrid;
            
            for(let i=0; i < totalSlots; i++) {
                const col = i % CONFIG.atlasGrid;
                const row = Math.floor(i / CONFIG.atlasGrid);
                const img = images[i % images.length];
                
                const aspect = img.width / img.height;
                let dw = size, dh = size;
                if (aspect > 1) dh = size / aspect;
                else dw = size * aspect;
                
                const dx = col * size + (size - dw)/2;
                const dy = row * size + (size - dh)/2;
                
                ctx.save();
                ctx.beginPath();
                ctx.arc(col*size + size/2, row*size + size/2, size/2 - 2, 0, Math.PI*2);
                ctx.clip();
                ctx.drawImage(img, dx, dy, dw, dh);
                ctx.restore();
                
                ctx.beginPath();
                ctx.arc(col*size + size/2, row*size + size/2, size/2 - 2, 0, Math.PI*2);
                ctx.strokeStyle = "rgba(255,255,255,0.3)";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            textureAtlasTexture.needsUpdate = true;
            material.uniforms.uColor.value.setHex(0xffffff);
            document.getElementById('colorPicker').value = "#ffffff";
        }

        // --- 4. Three.js åˆå§‹åŒ– ---
        function initThree() {
            initTextureAtlas();
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50; 

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                logarithmicDepthBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            textureAtlasTexture.anisotropy = maxAnisotropy;

            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;    
            controls.autoRotate = true;    
            controls.autoRotateSpeed = 1.0; 

            createParticleSystem();
            initUI();
            
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            animate();
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setShape('heart');
            }, 1000);
        }

        // --- 5. ç²’å­ç³»ç»Ÿ ---
        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const imgIndices = new Float32Array(CONFIG.particleCount);
            const rotations = new Float32Array(CONFIG.particleCount); 
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                
                sizes[i] = 0.5 + Math.random() * 0.5;
                imgIndices[i] = Math.floor(Math.random() * (CONFIG.atlasGrid * CONFIG.atlasGrid));
                rotations[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('imgIndex', new THREE.BufferAttribute(imgIndices, 1));
            geometry.setAttribute('rotation', new THREE.BufferAttribute(rotations, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(CONFIG.defaultColor) },
                    uTexture: { value: textureAtlasTexture },
                    uAtlasGrid: { value: CONFIG.atlasGrid },
                    uExpansion: { value: 0 },
                    uAudioLevel: { value: 0 },
                    uMouse: { value: new THREE.Vector3(0, 0, 0) },
                    uPixelRatio: { value: window.devicePixelRatio },
                    uSize: { value: CONFIG.particleSize }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uExpansion;
                    uniform float uAudioLevel;
                    uniform vec3 uMouse;
                    uniform float uPixelRatio;
                    uniform float uSize;

                    attribute float size;
                    attribute float imgIndex;
                    attribute float rotation;
                    
                    varying float vImgIndex;
                    varying float vOpacity;
                    varying float vRotation;

                    float random(vec3 st) { return fract(sin(dot(st.xyz, vec3(12.9898,78.233,45.164))) * 43758.5453123); }

                    void main() {
                        vImgIndex = imgIndex;
                        vRotation = rotation;
                        vec3 pos = position;
                        
                        vec3 dir = normalize(pos);
                        float rnd = random(position); 
                        float expansionFactor = uExpansion * (8.0 + rnd * 10.0);
                        pos += dir * expansionFactor;

                        float dist = length(pos);
                        pos += dir * sin(dist * 0.2 - uTime * 3.0) * uAudioLevel * 5.0;

                        if (uExpansion < 0.1) {
                            pos.x += sin(uTime * 0.3 + pos.y * 0.1) * 0.2;
                            pos.y += cos(uTime * 0.3 + pos.x * 0.1) * 0.2;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        
                        float depthOffset = (random(vec3(imgIndex)) - 0.5) * 0.5;
                        mvPosition.z += depthOffset;

                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = uSize * size * uPixelRatio * (60.0 / -mvPosition.z);
                        
                        vOpacity = smoothstep(120.0, 10.0, -mvPosition.z); 
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform sampler2D uTexture;
                    uniform float uAtlasGrid;
                    
                    varying float vImgIndex;
                    varying float vOpacity;
                    varying float vRotation;

                    void main() {
                        float col = mod(vImgIndex, uAtlasGrid);
                        float row = floor(vImgIndex / uAtlasGrid);
                        
                        vec2 uv = gl_PointCoord;
                        vec2 atlasUV = (uv + vec2(col, row)) / uAtlasGrid;
                        vec4 texColor = texture2D(uTexture, vec2(atlasUV.x, 1.0 - atlasUV.y));

                        if (texColor.a * vOpacity < 0.6) discard;

                        vec3 finalColor = texColor.rgb * uColor;
                        gl_FragColor = vec4(finalColor, 1.0); 
                    }
                `,
                transparent: false, 
                depthTest: true, 
                depthWrite: true, 
                blending: THREE.NoBlending 
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            targetPositions = Array.from(positions);
        }

        // --- 6. ç²¾ç»†æ¨¡å‹ä½ç½®è®¡ç®— (ä¿®å¤äº†ç¼ºå¤±çš„Case) ---
        function calculateShapePositions(type) {
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const count = CONFIG.particleCount;
            const rand = () => Math.random() * 2 - 1;

            for (let i = 0; i < count; i++) {
                let x = 0, y = 0, z = 0;
                const idx = i * 3;
                const u = Math.random();
                const v = Math.random();
                const theta = u * Math.PI * 2;
                const phi = v * Math.PI;

                switch(type) {
                    case 'tree': 
                        if (i < count * 0.15) {
                            const h = v * 12; 
                            const r = 2.0; 
                            x = r * Math.cos(theta) * Math.sqrt(Math.random()); 
                            z = r * Math.sin(theta) * Math.sqrt(Math.random());
                            y = h - 25; 
                        } else {
                            const layer = Math.random();
                            let hBase, hTop, rBase;
                            if (layer < 0.4) { hBase = -15; hTop = 5; rBase = 16; } 
                            else if (layer < 0.75) { hBase = -2; hTop = 15; rBase = 12; } 
                            else { hBase = 10; hTop = 25; rBase = 7; } 
                            
                            const lv = Math.random();
                            const h = hBase + lv * (hTop - hBase);
                            const rMax = rBase * (1 - lv);
                            const r = rMax * Math.sqrt(Math.random()); 
                            
                            x = r * Math.cos(theta);
                            z = r * Math.sin(theta);
                            y = h - (r / rBase) * 2; 
                        }
                        break;
                        
                    case 'heart': 
                        { 
                            const t = theta;
                            x = 16 * Math.pow(Math.sin(t), 3);
                            y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                            const scale = 1 - v; 
                            x *= scale;
                            y *= scale;
                            const zThick = 4 * scale * Math.sin(v * Math.PI);
                            z = (rand()) * zThick;
                        } 
                        break;
                        
                    case 'rose': 
                        { 
                            const n = 5; 
                            const r = Math.sin(n*theta) * 10 + 15;
                            const h = Math.sqrt(Math.max(0, 25*25 - r*r*0.5));
                            const radius = v * 15;
                            const angle = theta * 3 + v * 10;
                            const petalH = Math.sin(angle * 2.5) * 3 * v; 
                            x = radius * Math.cos(angle);
                            z = radius * Math.sin(angle);
                            y = petalH + (v * 10) - 5;
                            if (v < 0.2) y += 3;
                        } 
                        break;

                    case 'butterfly':
                        if (i < count * 0.1) {
                            x = rand() * 1;
                            y = (v - 0.5) * 15;
                            z = rand() * 1;
                        } else {
                            const t = theta;
                            const r = (Math.exp(Math.cos(t)) - 2*Math.cos(4*t) + Math.pow(Math.sin(t/12),5)) * 6;
                            let wx = r * Math.cos(t);
                            let wy = r * Math.sin(t);
                            const wingAngle = Math.PI / 6; 
                            x = wx;
                            y = wy;
                            z = Math.abs(wx) * Math.tan(wingAngle) + rand();
                        }
                        break;

                    case 'ring': 
                        if (i < count * 0.8) {
                            const R=12, r=1.5;
                            x = (R+r*Math.cos(phi))*Math.cos(theta);
                            y = r*Math.sin(phi);
                            z = (R+r*Math.cos(phi))*Math.sin(theta);
                            const ty=y; y=y*Math.cos(0.5)-z*Math.sin(0.5); z=ty*Math.sin(0.5)+z*Math.cos(0.5); 
                        } else {
                            const dr = (1-Math.abs(v-0.5)*2) * 5; 
                            const dy = (v-0.5) * 8;
                            x = dr * Math.cos(theta);
                            z = dr * Math.sin(theta);
                            y = dy + 14; 
                            const ty=y; y=y*Math.cos(0.5)-z*Math.sin(0.5); z=ty*Math.sin(0.5)+z*Math.cos(0.5);
                        }
                        break;

                    case 'star':
                        {
                            const rIn = 7;
                            const angle = theta;
                            const angleStep = Math.PI / 5;
                            const alpha = (angle % (2 * angleStep)) - angleStep;
                            const rBase = 12 * (1 + 0.6 * Math.cos(5 * angle)); 
                            const thickness = 4 * (1 - v);
                            x = rBase * v * Math.cos(angle);
                            y = rBase * v * Math.sin(angle);
                            z = (rand()) * thickness;
                        }
                        break;

                    case 'moon': // [ä¿®å¤] æ ‡å‡†æœˆç‰™
                        {
                            // ä½¿ç”¨å¸ƒå°”é€»è¾‘ï¼šåœ¨ä¸€ä¸ªå¤§åœ†å†…ï¼Œä½†ä¸åœ¨ä¸€ä¸ªåç§»çš„å°åœ†å†…
                            // éšæœºç‚¹æ‹’ç»é‡‡æ ·æ³•æ•ˆç‡ä½ï¼Œè¿™é‡Œç”¨æåæ ‡æ˜ å°„
                            // æœˆç‰™ä¸»ä½“
                            const angle = u * Math.PI * 2;
                            // ç®€å•çš„æœˆç‰™å‚æ•°æ–¹ç¨‹
                            // å¤–åœ† R=15, å†…åœ†åˆ‡é™¤
                            const R = 15;
                            // æˆ‘ä»¬è®©è§’åº¦åªåˆ†å¸ƒåœ¨åŠåœ†+ä¸€ç‚¹ç‚¹ï¼Œç„¶åæŒ¤å‹å®½åº¦
                            // ç®€åŒ–æ–¹æ¡ˆï¼šç”»ä¸€ä¸ªåœ†ç¯çš„ä¸€éƒ¨åˆ†ï¼Œä¸”å®½åº¦æ¸å˜
                            const alpha = (u - 0.5) * Math.PI * 1.2; // -108åº¦åˆ°108åº¦
                            const baseW = Math.cos(alpha); // ä¸­é—´å®½ä¸¤å¤´å°–
                            if (baseW > 0) {
                                const w = baseW * 6;
                                const r = R - (v * w); // ä»å¤–å‘å†…
                                x = r * Math.sin(alpha);
                                y = r * Math.cos(alpha);
                                z = (rand()) * 3 * baseW; // åšåº¦
                            } else {
                                // å¡«å……çœ‹ä¸è§çš„åœ°æ–¹
                                x=0;y=0;z=0;
                            }
                        }
                        break;

                    case 'infinity': // [ä¿®å¤] åŒæ‰­çº¿
                        {
                            const t = u * Math.PI * 2;
                            const scale = 15;
                            const denom = 1 + Math.sin(t)*Math.sin(t);
                            x = scale * Math.cos(t) / denom;
                            y = scale * Math.sin(t) * Math.cos(t) / denom;
                            // è«æ¯”ä¹Œæ–¯æ‰­è½¬
                            z = (v-0.5) * 4 * Math.sin(t*0.5);
                        }
                        break;

                    case 'dna': // [ä¿®å¤] åŒèºæ—‹
                        {
                             const h = (u - 0.5) * 40; // é«˜åº¦
                             const angle = u * Math.PI * 8; // æ—‹è½¬åœˆæ•°
                             const r = 6;
                             
                             if (v < 0.4) {
                                 // é“¾1
                                 x = r * Math.cos(angle);
                                 z = r * Math.sin(angle);
                                 y = h;
                             } else if (v < 0.8) {
                                 // é“¾2 (ç›¸ä½å·®PI)
                                 x = r * Math.cos(angle + Math.PI);
                                 z = r * Math.sin(angle + Math.PI);
                                 y = h;
                             } else {
                                 // è¿æ¥é”®
                                 // éšæœºè¿æ¥ä¸¤ä¸ªç›¸å¯¹çš„ç‚¹
                                 const t = Math.random(); // æ’å€¼
                                 const x1 = r * Math.cos(angle);
                                 const z1 = r * Math.sin(angle);
                                 const x2 = r * Math.cos(angle + Math.PI);
                                 const z2 = r * Math.sin(angle + Math.PI);
                                 x = x1 * t + x2 * (1-t);
                                 z = z1 * t + z2 * (1-t);
                                 y = h;
                             }
                        }
                        break;
                    
                    case 'fireworks': // [ä¿®å¤] æ”¾å°„çº¿
                         {
                             // ä»ä¸­å¿ƒå‘å¤–å‘å°„çš„çº¿æ¡
                             // éšæœºæ–¹å‘
                             const theta = Math.random() * Math.PI * 2;
                             const phi = Math.acos(2 * Math.random() - 1);
                             // éšæœºè·ç¦»ï¼Œåå‘å¤–éƒ¨
                             const len = 10 + Math.random() * 20; 
                             // å°†ç²’å­æ’åˆ—åœ¨è¿™äº›å°„çº¿ä¸Š
                             // v å†³å®šåœ¨å°„çº¿ä¸Šçš„ä½ç½®
                             const dist = v * len; 
                             
                             const nx = Math.sin(phi) * Math.cos(theta);
                             const ny = Math.sin(phi) * Math.sin(theta);
                             const nz = Math.cos(phi);
                             
                             x = nx * dist;
                             y = ny * dist;
                             z = nz * dist;
                         }
                         break;

                    case 'galaxy': 
                        if (i < count * 0.3) {
                            const r = 5 * Math.cbrt(Math.random());
                            x = r * Math.sin(phi)*Math.cos(theta);
                            z = r * Math.sin(phi)*Math.sin(theta);
                            y = r * Math.cos(phi) * 0.6; 
                        } else {
                            const arm = i % 2; 
                            const r = 5 + v * 20;
                            const spin = r * 0.4 + arm * Math.PI;
                            const spread = (Math.random()-0.5) * (r * 0.2);
                            x = (r + spread) * Math.cos(spin);
                            z = (r + spread) * Math.sin(spin);
                            y = (rand()) * (20 - r) * 0.05; 
                        }
                        break;
                    
                    case 'diamond':
                        {
                            const hTop = 5;
                            const hBottom = -8;
                            const rMid = 10;
                            const rTop = 6;
                            
                            if (v > 0.4) {
                                const ratio = (v - 0.4) / 0.6;
                                const r = rMid * (1-ratio) + rTop * ratio;
                                const h = ratio * hTop;
                                x = r * Math.cos(theta);
                                z = r * Math.sin(theta);
                                y = h;
                            } else {
                                const ratio = v / 0.4;
                                const r = rMid * ratio;
                                const h = (ratio - 1) * Math.abs(hBottom);
                                x = r * Math.cos(theta);
                                z = r * Math.sin(theta);
                                y = h;
                            }
                        }
                        break;

                    case 'gift':
                         if (i < count * 0.8) {
                             const s = 12;
                             const face = Math.floor(Math.random()*6);
                             let u1 = (Math.random()-0.5)*2 * s;
                             let v1 = (Math.random()-0.5)*2 * s;
                             if(face==0) {x=s; y=u1; z=v1;}
                             else if(face==1) {x=-s; y=u1; z=v1;}
                             else if(face==2) {x=u1; y=s; z=v1;}
                             else if(face==3) {x=u1; y=-s; z=v1;}
                             else if(face==4) {x=u1; y=v1; z=s;}
                             else {x=u1; y=v1; z=-s;}
                         } else {
                             const t = theta;
                             const s = 5;
                             x = s * Math.sin(2*t); 
                             y = 14 + rand();
                             z = s * Math.cos(t);
                         }
                         break;
                    
                    case 'crown':
                        {
                            const r = 10;
                            const spikes = 6;
                            if (v < 0.5) {
                                x = r * Math.cos(theta);
                                z = r * Math.sin(theta);
                                y = v * 10 - 5;
                            } else {
                                const spikeH = Math.abs(Math.sin(theta * spikes / 2)) * 8;
                                const rOut = r + (v-0.5)*4;
                                x = rOut * Math.cos(theta);
                                z = rOut * Math.sin(theta);
                                y = 0 + (v-0.5)*10 + spikeH * (v-0.5)*2;
                            }
                        }
                        break;

                    case 'music':
                        if (i < count * 0.3) {
                            x = -5 + 4 * Math.sin(phi)*Math.cos(theta);
                            y = -10 + 3 * Math.cos(phi); 
                            z = 4 * Math.sin(phi)*Math.sin(theta);
                            const tx=x; x=x*Math.cos(0.3)-y*Math.sin(0.3); y=tx*Math.sin(0.3)+y*Math.cos(0.3);
                        } else if (i < count * 0.7) {
                            x = 4 + rand()*0.5;
                            y = -5 + v * 20;
                            z = rand()*0.5;
                        } else {
                            const t = v; 
                            x = 4 + t * 4;
                            y = 15 - t * t * 8;
                            z = Math.sin(t*Math.PI)*2;
                        }
                        break;

                    case 'lips':
                        {
                            const t = theta; 
                            const w = 12;
                            x = w * Math.cos(t);
                            let lipH, lipD;
                            if (Math.sin(t) > 0) { 
                                lipH = 4 * Math.sin(t) - 1.5 * Math.abs(Math.sin(2*t)); 
                                lipD = 3 * Math.sin(t); 
                            } else {
                                lipH = 5 * Math.sin(t);
                                lipD = 4 * Math.abs(Math.sin(t));
                            }
                            y = lipH;
                            z = (rand()) * lipD;
                            y += (y > 0 ? 1 : -1) * 0.5;
                        }
                        break;
                    
                    case 'balloon':
                        if (i < count * 0.9) {
                            const r = 11;
                            y = r * Math.cos(phi);
                            let scaleY = 1.0;
                            if (y < 0) scaleY = 1.0 + Math.abs(y)*0.08; 
                            x = r * Math.sin(phi) * Math.cos(theta) * (1 - Math.max(0, -y/25)); 
                            z = r * Math.sin(phi) * Math.sin(theta) * (1 - Math.max(0, -y/25));
                            y *= scaleY;
                            y += 5; 
                        } else {
                            x = Math.sin(v * 10) * 1;
                            z = Math.cos(v * 10) * 1;
                            y = -8 - v * 15;
                        }
                        break;

                    case 'angel':
                        {
                            const side = (i % 2 === 0) ? 1 : -1;
                            const t = u * Math.PI; 
                            const r = Math.sin(t) * 18;
                            const featherW = v * 4; 
                            let wx = 3 + r * Math.cos(t/2) * 1.5;
                            let wy = r * Math.sin(t/2) * 2.0;
                            wy -= featherW * 1.5;
                            x = side * wx;
                            y = wy;
                            z = Math.abs(wx)*0.2 + rand(); 
                            z -= 5;
                        }
                        break;

                    case 'snowflake':
                        {
                            const arm = Math.floor(Math.random() * 6);
                            const angle = (arm / 6) * Math.PI * 2;
                            const armL = 16;
                            let d = v * armL;
                            let dx = d;
                            let dy = 0;
                            const branch1 = 0.5 * armL;
                            const branch2 = 0.8 * armL;
                            if (Math.abs(d - branch1) < 2) {
                                dy += (Math.random()-0.5) * 6; 
                                dx = branch1 + (Math.random()-0.5); 
                            } else if (Math.abs(d - branch2) < 1.5) {
                                dy += (Math.random()-0.5) * 4;
                                dx = branch2 + (Math.random()-0.5);
                            }
                            x = dx * Math.cos(angle) - dy * Math.sin(angle);
                            y = dx * Math.sin(angle) + dy * Math.cos(angle);
                            z = rand() * 0.5; 
                        }
                        break;

                    case 'sphere':
                    default: 
                        { const r=16*Math.cbrt(Math.random()); x=r*Math.sin(phi)*Math.cos(theta); y=r*Math.sin(phi)*Math.sin(theta); z=r*Math.cos(phi); } break;
                }
                positions[idx] = x; positions[idx+1] = y; positions[idx+2] = z;
            }
            return positions;
        }

        // --- 7. äº¤äº’æ§åˆ¶ ---
        function setShape(shapeId) {
            currentShape = shapeId;
            updateTargetPositions(calculateShapePositions(shapeId));
            showToast(`å·²åˆ‡æ¢: ${SHAPES.find(s=>s.id===shapeId).name}`);
        }

        function updateTargetPositions(newPosArray) { targetPositions = newPosArray; }

        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
        function handleImageUpload(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            const images = [];
            let loadedCount = 0;
            showToast(`æ­£åœ¨å¤„ç† ${files.length} å¼ ç…§ç‰‡...`);
            for (let i = 0; i < files.length; i++) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        images.push(img);
                        loadedCount++;
                        if (loadedCount === files.length) {
                            updateAtlasWithImages(images);
                            showToast(`æˆåŠŸåŠ è½½ ${files.length} å¼ ç…§ç‰‡ï¼`);
                        }
                    };
                };
                reader.readAsDataURL(files[i]);
            }
        }

        const videoElement = document.getElementById('input_video');
        const handIndicator = document.getElementById('hand-indicator');
        const handStatus = document.getElementById('hand-status');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const d = Math.sqrt(Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2));
                let factor = (d - 0.05) * 3.5; 
                targetHandExpansion = Math.max(0, Math.min(1, factor));
                handIndicator.className = "w-3 h-3 rounded-full bg-green-400 shadow-[0_0_8px_#4ade80]";
                handStatus.innerText = `æ‰‹åŠ¿: ${factor > 0.4 ? "å¼ å¼€" : "åˆæ‹¢"}`;
                handStatus.className = "text-xs font-bold text-green-400";
            } else {
                targetHandExpansion = 0;
                handIndicator.className = "w-3 h-3 rounded-full bg-red-500";
                handStatus.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                handStatus.className = "text-xs font-bold text-gray-400";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start().catch(e => console.warn("Camera fallback"));

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.innerText = msg; toast.style.opacity = 1;
            setTimeout(() => toast.style.opacity = 0, 3000);
        }

        function toggleAudio() {
            if (!isAudioActive) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                        audioContext.createMediaStreamSource(stream).connect(analyser);
                        dataArray = new Uint8Array(analyser.frequencyBinCount);
                        isAudioActive = true;
                        showToast("ğŸµ éº¦å…‹é£å·²è¿æ¥ï¼Œæ’­æ”¾éŸ³ä¹è¯•è¯•ï¼");
                        document.getElementById('audioBtn').classList.add('bg-emerald-600', 'border-emerald-400');
                    }).catch(() => showToast("âŒ æ— æ³•è®¿é—®éº¦å…‹é£"));
                } else {
                    audioContext.resume();
                    isAudioActive = true;
                    document.getElementById('audioBtn').classList.add('bg-emerald-600', 'border-emerald-400');
                }
            } else {
                isAudioActive = false;
                document.getElementById('audioBtn').classList.remove('bg-emerald-600', 'border-emerald-400');
            }
        }

        document.getElementById('colorPicker').addEventListener('input', (e) => material.uniforms.uColor.value.set(e.target.value));
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            material.uniforms.uMouse.value.x = mouse.x * 20; 
            material.uniforms.uMouse.value.y = mouse.y * 20;
        }

        async function toggleFullScreen() {
            try {
                if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
                else await document.exitFullscreen();
            } catch (err) { showToast("æš‚ä¸æ”¯æŒå…¨å±"); }
        }

        function takeSnapshot() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'romantic-moment.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
            showToast("âœ… å·²ä¿å­˜ç²¾å½©ç¬é—´");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
        }

        // --- 8. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;
            
            if(controls) controls.update();

            handExpansion += (targetHandExpansion - handExpansion) * 0.05;
            material.uniforms.uExpansion.value = handExpansion * CONFIG.handSensitivity;

            if (isAudioActive && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let avg = 0; for(let i=0; i<dataArray.length; i++) avg+=dataArray[i];
                material.uniforms.uAudioLevel.value = avg / 128.0 / dataArray.length; 
            } else {
                material.uniforms.uAudioLevel.value = 0;
            }

            if (targetPositions.length > 0) {
                const pos = particles.geometry.attributes.position.array;
                const speed = 0.04; 
                for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                    pos[i] += (targetPositions[i] - pos[i]) * speed;
                }
                
                if (handExpansion < 0.1) {
                    for(let i=0; i<CONFIG.particleCount; i++) {
                        pos[i*3+1] += Math.sin(time*0.5 + pos[i*3]*0.05) * 0.015;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        initThree();
    </script>
</body>
</html>